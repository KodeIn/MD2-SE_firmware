#include <intrinsics.h>
#include <iostm8s003f3.h>

#define RED PA_ODR_ODR3
#define BLUE PD_ODR_ODR3
#define GREEN PD_ODR_ODR4

#define RESET PC_ODR_ODR5
#define HZ PC_ODR_ODR4
#define LANG PC_ODR_ODR3

#define EXP PC_ODR_ODR7

#define BTN PC_IDR_IDR6

#define PAL 0
#define NTSC 1
#define JAP 0
#define ENG 1

unsigned int status = 1;

void Delayus(void)   
{    
    asm("nop"); 
    asm("nop");   
    asm("nop");   
    asm("nop");    
} 

void Delayms(unsigned int time)   
{   
    unsigned int i;   
    while(time--)     
    for(i=900;i>0;i--)   
    Delayus();    
} 

void SetSwitches(unsigned int stat)
{
  switch (stat)
  {
    case 1:
      RED = 0;
      GREEN = 0;
      BLUE = 1;
      HZ = NTSC;
      LANG = JAP;
      EXP = 1;
      break;
    case 2:
      RED = 0;
      GREEN = 1;
      BLUE = 0;
      HZ = NTSC;
      LANG = ENG;
      EXP = 1;
      break;
    case 0:
      RED = 1;
      GREEN = 0;
      BLUE = 0;
      HZ = PAL;
      LANG = ENG;
      EXP = 0;
      break;
  }
}

void ResetMD(){
  RED = 1;
  GREEN = 1;
  BLUE = 1;
  
  RESET = 1;
  Delayms(500);
  RESET = 0;
  
  RED = 0;
  GREEN = 0;
  BLUE = 0;
  Delayms(500);
  SetSwitches(status);
}

unsigned int btnOn = 0;

//
//  Timer 1 Overflow handler.
//
#pragma vector = TIM1_OVR_UIF_vector
__interrupt void TIM1_UPD_OVF_IRQHandler(void)
{ 
  if (BTN == 0 && btnOn > 1){
    SetSwitches(status);
    btnOn = 0;
  } 
  
  
  if (BTN == 1){
    btnOn++;
  }
  
  if (BTN == 0 && btnOn == 1){
    ResetMD();
    btnOn = 0;
  } 

  if (BTN == 1 && btnOn > 2){
      switch (status)
      {
        case 0:
          RED = 0;
          GREEN = 0;
          BLUE = 1;
          
          status = 1;
          break;
          
         case 1:
          RED = 0;
          GREEN = 1;
          BLUE = 0;
          
          status = 2;
          break;
          
         case 2:
          RED = 1;
          GREEN = 0;
          BLUE = 0;
          
          status = 0;
          break;
      }
    }
    
  TIM1_SR1_UIF = 0;               //  Reset the interrupt otherwise it will fire again straight away.
}

//
//  Process the interrupt generated by the pressing of the button on PD4.
//

#pragma vector = 6
__interrupt void EXTI_PORTB_IRQHandler(void)
{
  btnOn = 1;
}


void InitialiseSystemClock()
{
  CLK_ICKR = 0;                       //  Reset the Internal Clock Register.
  CLK_ICKR_HSIEN = 1;                 //  Enable the HSI.
  CLK_ECKR = 0;                       //  Disable the external clock.
  while (CLK_ICKR_HSIRDY == 0);       //  Wait for the HSI to be ready for use.
  CLK_CKDIVR = 0;                     //  Ensure the clocks are running at full speed.
  CLK_PCKENR1 = 0xff;                 //  Enable all peripheral clocks.
  CLK_PCKENR2 = 0xff;                 //  Ditto.
  CLK_CCOR = 0;                       //  Turn off CCO.
  CLK_HSITRIMR = 0;                   //  Turn off any HSIU trimming.
  CLK_SWIMCCR = 0;                    //  Set SWIM to run at clock / 2.
  CLK_SWR = 0xe1;                     //  Use HSI as the clock source.
  CLK_SWCR = 0;                       //  Reset the clock switch control register.
  CLK_SWCR_SWEN = 1;                  //  Enable switching.
  while (CLK_SWCR_SWBSY != 0);        //  Pause while the clock switch is busy.
}

//
//      Reset Timer 2 to a known state
//
void InitialiseTimer2()
{
    TIM2_CR1 = 0;               // Turn everything TIM2 related off.
    TIM2_IER = 0;
    TIM2_SR2 = 0;
    TIM2_CCER1 = 0;
    TIM2_CCER2 = 0;
    TIM2_CCER1 = 0;
    TIM2_CCER2 = 0;
    TIM2_CCMR1 = 0;
    TIM2_CCMR2 = 0;
    TIM2_CCMR3 = 0;
    TIM2_CNTRH = 0;
    TIM2_CNTRL = 0;
    TIM2_PSCR = 0;
    TIM2_ARRH  = 0;
    TIM2_ARRL  = 0;
    TIM2_CCR1H = 0;
    TIM2_CCR1L = 0;
    TIM2_CCR2H = 0;
    TIM2_CCR2L = 0;
    TIM2_CCR3H = 0;
    TIM2_CCR3L = 0;
    TIM2_SR1 = 0;
}

//
//  Setup Timer 1 to generate a 20 Hz interrupt based upon a 16 MHz timer.
//
void SetupTimer1()
{
    
  TIM1_PSCRH = 0x00;       // Prescalar = 256
  TIM1_PSCRL = 0xff;
  TIM1_CR1_DIR = 0;     // Up counter
  TIM1_ARRH = 0x7a;     // High byte of 50,000.
  TIM1_ARRL = 0x12;     // Low byte of 50,000.
  TIM1_IER_UIE = 1;     // Enable the update interrupts.
  TIM1_CR1_CEN = 1;     // Finally enable the timer.
}

//
//  Setup Timer 2 to generate a 20 Hz interrupt based upon a 16 MHz timer.
//
void SetupTimer2()
{
    /*
    TIM2_PSCR = 0x08;       //  Prescaler = 256.
    TIM2_ARRH = 0x7a;       //  High byte of 50,000.
    TIM2_ARRL = 0x12;       //  Low byte of 50,000.
    TIM2_IER_UIE = 1;       //  Enable the update interrupts.
    TIM2_CR1_CEN = 1;       //  Finally enable the timer.*/
    TIM2_PSCR = 0x03;       //  Prescaler = 1.
    TIM2_ARRH = 0xc3;       //  High byte of 50,000.
    TIM2_ARRL = 0x50;       //  Low byte of 50,000.
    TIM2_CCR1H = 0x30;      //  High byte of 12,500
    TIM2_CCR1L = 0xd4;      //  Low byte of 12,500
    TIM2_CCER1_CC1P = 0;    //  Active high.
    TIM2_CCER1_CC1E = 1;    //  Enable compare mode for channel 1
    TIM2_CCMR1_OC1M = 6;    //  PWM Mode 1 - active if counter < CCR1, inactive otherwise.
    TIM2_CR1_CEN = 1;       //  Finally enable the timer.
}

//
//  Main program loop.
//
void main()
{
    //
    //  Initialise the system.
    //
    __disable_interrupt();
    InitialiseSystemClock();
    
    /*
    *     Ports setup
    */
    PA_ODR = 0;         // all pins turned off 
    PD_ODR = 0;         // all pins turned off 
    PC_ODR = 0;         // all pins turned off 
    
    PA_DDR = 0xff;          //  All pins are outputs.
    PA_CR1 = 0xff;          //  Push-Pull outputs.
    PA_CR2 = 0xff;          //  Output speeds up to 10 MHz.
    
    PD_DDR = 0xff;          //  All pins are outputs.
    PD_CR1 = 0xff;          //  Push-Pull outputs.
    PD_CR2 = 0xff;          //  Output speeds up to 10 MHz.
    
    PC_DDR_DDR3 = 1;
    PC_DDR_DDR4 = 1;
    PC_DDR_DDR5 = 1;
    PC_DDR_DDR7 = 1;
    PC_CR1_C13 = 1;
    PC_CR1_C14 = 1;
    PC_CR1_C15 = 1;
    PC_CR1_C17 = 1;
    PC_CR2_C23 = 1;
    PC_CR2_C24 = 1;
    PC_CR2_C25 = 1;
    PC_CR2_C27 = 1;
    
    PC_DDR_DDR6 = 0;        //  PB0 is input.
    PC_CR1_C16 = 1;         //  PB0 has pull-up.
    //
    //  Set up the interrupt.
    //
    EXTI_CR1_PBIS = 2;      //  Interrupt on falling edge.
    EXTI_CR2_TLIS = 0;      //  Falling edge only.
    
    //InitialiseTimer2();
    SetupTimer1();
    //SetupTimer2();
    
    __enable_interrupt();

    SetSwitches(2);
    
    while (1)
    {
        __wait_for_interrupt();
    }
}
